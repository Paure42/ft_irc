 Sont éliminatoires pour ce projet:
- read(2)/write(2) bloquants (c'est à dire non précédés d'une
vérification par select(2) qu'ils ne seront pas bloquants)
- threads
- fork

FD_ZERO()

Il y a bien un FD_ZERO() avant l'appel à select(2) sur tous les
FD_SET utilisés ?

fd_set en écriture

Pour l'écriture, seuls les file descriptors sur lesquels on a
quelque chose à écrire sont mis dans le fd_set en écriture ?

timeout

Le timeout de select(2) est géré intelligemment (timeout NULL
pour que select(2) ne dèbloque que lorsque quelque chose arrive
sur une socket ou lorsqu'une socket est fermée) ?

read

Un seul read doit être fait par file descriptor, après le
select.

write

Un seul write doit être fait par file descriptor, après le
select.

Gestion du read

On doit avoir une gestion correcte du nombre d'octets réellement lus + une déconnexion si read(2) renvoie 0.

Réception des commandes

On doit avoir une fusion des paquets lus pour former une
commande. Testez avec nc en envoyant une commande entrecoupée de
Ctrl+D pour flusher les buffers. La commande doit être
interprétée normalement, pas de commande inconnue ou autre.

Buffer tournant

On a un buffer tournant en lecture ?

Buffer tournant ++

On a un buffer tournant en écriture ?

Les commandes

Les messages

Testez avec le client du projet, est-ce que les messages passent
bien quand on a deux clients connectés ?

Plus de clients

Est-ce que les messages passent bien quand on a plus de deux
clients connectés ?

Nickname

La commande Nickname est gérée ? Testez dans le client :

/nick _nickname_

Connexion au serveur

Ca gère la connexion au serveur depuis la ligne de commandes ? Testez :

$> ./client

Connexion dans le client

/connect _host_[:port] fonctionne ?

Connexion répétée dans le client

/connect _host_[:port], alors qu'on est déjà connecté fonctionne ?

User messages

On peut envoyer des messages de user à user ? Testez dans le client :

/msg

Gestion des channels

Ça gère les channels ?
/join, /leave, et les messages sont bien distincts sur chaque
channel ?

Who

La commande who permet de savoir qui est logué sur le channel ?
Testez dans le client :

/who

Bonus

Support de l IPv6

Le projet supporte à la fois l'IPv4 et l'IPv6.

Respect de la RFC

Le projet respecte le protocole IRC défini par la RFC (rfc 1459
ou rfc 2812).

Client graphique

Le projet gère un client en GTK/qt/ncurse, etc... qui fonctionne
(pas juste une pauvre fenêtre qui ne fait rien !).

D autres bonus

S'il y a d'autres bonus, comptez-les ici - vous pouvez
comptabiliser jusqu'à 5 bonus. Les bonus doivent être 100%
fonctionnels.

Exemple de bonus valides:
- gestion d'un login/password pour se connecter au serveur
- gestion d'une clef pour rentrer sur un channel
- gestion d'un prompt
- complétion lors d’un /join
- complétion lors d’un /msg 
